package main

import (
	"fmt"
	"github.com/garyburd/redigo/redis"
	"html/template"
	"log"
	"math/rand"
	"net/http"
	"os"
	"sort"
	"time"
)

// data structure to hold the hit counts per host
type Hit struct {
	Host  string
	Count int
}

// global string to hold container's hostname
var host string

// To sort the hits slice by hostnames
type ByHost []Hit

func (h ByHost) Len() int           { return len(h) }
func (h ByHost) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h ByHost) Less(i, j int) bool { return h[i].Host < h[j].Host }

func handler(w http.ResponseWriter, r *http.Request) {
	// Increment only for requests for URL's "/" because chrome
	// seems to make multiple requests for whatever reason
	if r.URL.Path == "/" {
		//log.Println("Incrementing counter...")

		// connect to redis. The redis db host should be reachable as "db"
		// Using "db" as network alias & default port
		c, err := redis.Dial("tcp", "db:6379")
		if err != nil {
			panic(err)
		}
		defer c.Close()

		// INCR the value corresponding to the host key
		c.Do("INCR", host)
	}
	stats(w, "incr")
}

func stats(w http.ResponseWriter, context string) {
	// A pseudo variable to denote env specific variations
	env := os.Getenv("ENVIRONMENT")
	rotate := rand.Intn(180)

	// connect to redis. The redis db host should be reachable as "db"
	// Using "db" as network alias & default port
	c, err := redis.Dial("tcp", "db:6379")
	if err != nil {
		panic(err)
	}
	defer c.Close()

	keys, _ := redis.Strings(c.Do("KEYS", "*"))

	// Generate stats for all other hits per hosts
	var hits []Hit
	// The total number of hits for any environment
	total := 0
	for _, key := range keys {
		value, _ := redis.Int(c.Do("GET", key))
		hit := Hit{key, value}
		hits = append(hits, hit)
		total = total + value
	}

	// Sort the container hostnames so it looks nicer and consistent
	sort.Sort(ByHost(hits))

	// Using an anonymous struct, only needed to pass to the template
	data := struct {
		CurrentHost, Env string
		Rotate           int
		Hits             []Hit
		Context          string
		Total            int
	}{
		host, env, rotate, hits, context, total,
	}

	// Template stuff, with error handling (critical for troubleshooting)
	t, err := template.ParseFiles("tmpl/demo.html")
	if err != nil {
		log.Fatal("Parsing error: ", err)
		return
	}

	// Voila
	exeErr := t.Execute(w, data)
	if exeErr != nil {
		log.Fatal("Execute error: ", exeErr)
	}
}

func viewer(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == "/stats" {
		// log.Println("Viewing stats....")
		stats(w, "viewer")
	}
}

func init() {
	// The container "name" auto-generated by docker
	host = os.Getenv("HOSTNAME")

	// connect to redis. The redis db host should be reachable as "db"
	// Using "db" as network alias & default port
	c, err := redis.Dial("tcp", "db:6379")
	if err != nil {
		i := 0
		for {
			// try every two seconds to connect to db
			time.Sleep(2 * time.Second)
			c, err = redis.Dial("tcp", "db:6379")
			if err != nil {
				i += 1
				fmt.Printf("%s: No Connection to db. Attempt %d\n", host, i)
			} else {
				fmt.Printf("%s: Connection to db established.\n", host)
				break
			}
		}
	}
	defer c.Close()

	log.Printf("Initiating counter for %s\n", host)

	// INCR the value corresponding to the host key
	c.Do("SETNX", host, 0)
}

func main() {
	http.HandleFunc("/stats", viewer)
	http.HandleFunc("/", handler)
	server := &http.Server{
		Addr: ":8080",
	}
	log.Println("Starting counter-demo application...")
	log.Fatal(server.ListenAndServe())
}
