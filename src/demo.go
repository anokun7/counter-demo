package main

import (
	"encoding/json"
	"github.com/garyburd/redigo/redis"
	"github.com/gorilla/websocket"
	"html/template"
	"log"
	"math/rand"
	"net/http"
	"os"
	"os/signal"
	"sort"
	"strings"
	"syscall"
	"time"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin:     func(r *http.Request) bool { return true },
}

// data structure to hold the hit counts per host
type Hit struct {
	Host          string
	Count, Active int
}

// global string to hold container's hostname
var host string

// global const string to hold Database URL
const dbURL = "db:6379"

// To sort the hits slice by hostnames
type ByHost []Hit

func (h ByHost) Len() int           { return len(h) }
func (h ByHost) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h ByHost) Less(i, j int) bool { return h[i].Host < h[j].Host && h[i].Active < h[j].Active }

func redirecter(w http.ResponseWriter, r *http.Request) {
	// Redirect to /counter for requests for "/"
	if r.URL.Path == "/" || r.URL.Path == "" {
		//log.Println("Redirecting to /counter/")
		http.Redirect(w, r, "/counter/", http.StatusPermanentRedirect)
	}
}

func handler(w http.ResponseWriter, r *http.Request) {
	// The path where the application is being served
	if r.URL.Path == "/counter/" {
		//log.Println("Incrementing counter...")

		// connect to redis. The redis db host should be reachable as "db"
		// Using "db" as network alias & default port
		c, err := redis.Dial("tcp", dbURL)
		if err != nil {
			panic(err)
		}
		defer c.Close()

		// INCR the value corresponding to the host key
		// Prevent incrementing if container is shutting down
		terminated, _ := redis.Int(c.Do("EXISTS", "~"+host))
		if terminated != 1 {
			c.Do("INCR", host)
			c.Do("PERSIST", host)
		}
	}
	stats(r, w, "incr")
}

func stats(r *http.Request, w http.ResponseWriter, context string) {
	// A pseudo variable to denote env specific variations
	env := os.Getenv("ENVIRONMENT")
	rotate := rand.Intn(180)

	// Get client details
	client := r.RemoteAddr

	// Get the X-Forwarded-For IP's. Will work only when site is accessed via non-anonymous proxy
	for _, ip := range strings.Split(r.Header.Get("X-Forwarded-For"), ", ") {
		log.Printf("Access: %s -> %s\n", ip, r.RemoteAddr)
	}

	proxyips := r.Header.Get("X-Forwarded-For")

	// connect to redis.
	c, err := redis.Dial("tcp", dbURL)
	if err != nil {
		panic(err)
	}
	defer c.Close()

	// Get running containers only (all except those that begin with '~'
	keys, _ := redis.Strings(c.Do("KEYS", "[^~]*"))

	// Generate stats for all other hits per hosts
	var hits []Hit
	// The total number of hits for any environment
	total := 0
	for _, key := range keys {
		value, _ := redis.Int(c.Do("GET", key))
		//Detect leaks
		terminated, _ := redis.Int(c.Do("EXISTS", "~"+key))
		if terminated == 1 && key == host {
			log.Printf("%s: Found a leak. Deleting\n", key)
			redis.Int(c.Do("DEL", key))
			leakedValue, _ := redis.Int(c.Do("GET", "~"+key))
			redis.Int(c.Do("SET", key, value+leakedValue))
		} else {
			hits = append(hits, Hit{key, value, 1})
		}
		total = total + value
	}

	// Get terminated containers only (all starting with '~')
	tkeys, _ := redis.Strings(c.Do("KEYS", "~*"))

	for _, key := range tkeys {
		value, _ := redis.Int(c.Do("GET", key))
		hits = append(hits, Hit{strings.Trim(key, "~"), value, 0})
		total = total + value
	}

	// Sort the container hostnames so it looks nicer and consistent
	sort.Sort(ByHost(hits))

	// Using an anonymous struct, only needed to pass to the template
	data := struct {
		CurrentHost, Env string
		Rotate           int
		Hits             []Hit
		Context, Client  string
		Total            int
		ProxyIps         string
	}{
		host, env, rotate, hits, context, client, total, proxyips,
	}

	// Template stuff, with error handling (critical for troubleshooting)
	t, err := template.ParseFiles("tmpl/demo.html")
	if err != nil {
		log.Fatal("Parsing error: ", err)
		return
	}

	// Voila (template magic)
	exeErr := t.Execute(w, data)
	if exeErr != nil {
		log.Fatal("Execute error: ", exeErr)
	}
}

func viewer(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == "/counter/stats" {
		// log.Println("Viewing stats....")
		stats(r, w, "viewer")
	}
}

func init() {
	// The container "name" auto-generated by docker
	host = os.Getenv("HOSTNAME")

	// connect to redis. The redis db host should be reachable as "db"
	// Using "db" as network alias & default port
	c, err := redis.Dial("tcp", dbURL)
	if err != nil {
		i := 0
		for {
			// try every two seconds to connect to db
			time.Sleep(2 * time.Second)
			c, err = redis.Dial("tcp", dbURL)
			if err != nil {
				i += 1
				log.Printf("%s: No Connection to db. Attempt %d\n", host, i)
			} else {
				log.Printf("%s: Connection to db established.\n", host)
				break
			}
		}
	}
	defer c.Close()

	log.Printf("Initiating counter for %s\n", host)

	// INCR the value corresponding to the host key
	c.Do("SETNX", host, 0)
	// Auto cleanup if unused
	c.Do("EXPIRE", host, 60)
}

func main() {
	signalChannel := make(chan os.Signal, 1)
	exitChannel := make(chan bool, 1)

	// go routine to watch for signals, for graceful shutdown
	go shutdown(signalChannel, exitChannel)

	http.HandleFunc("/counter/total", func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s: Websocket launched\n", host)
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			log.Printf("%s: Error upgrading http to websocket: %s\n", host, err)
			return
		}

		c, err := redis.Dial("tcp", dbURL)
		if err != nil {
			log.Printf("%s: Error connecting to db: %s\n", host, err)
		}
		defer c.Close()

		for {
			time.Sleep(2 * time.Second)
			// The total number of hits for any environment
			total := 0
			keys, _ := redis.Strings(c.Do("KEYS", "*"))
			for _, key := range keys {
				value, _ := redis.Int(c.Do("GET", key))
				total = total + value
				wsTotal, err := json.Marshal(total)
				if err != nil {
					log.Printf("%s: Error in json.Marshal(): %s\n", host, err)
					return
				}
				conn.WriteMessage(websocket.TextMessage, wsTotal)
			}
		}
	})
	http.HandleFunc("/counter/stats", viewer)
	http.HandleFunc("/counter/", handler)
	http.HandleFunc("/", redirecter)
	server := &http.Server{
		Addr: ":8080",
	}
	log.Printf("%s: Starting counter-demo application...", host)
	log.Fatal(server.ListenAndServe())
	<-exitChannel
	os.Exit(0)
}

func shutdown(signalChannel chan os.Signal, exitChannel chan bool) {
	signal.Notify(signalChannel, syscall.SIGTERM, syscall.SIGINT)
	for {
		signal := <-signalChannel
		switch signal {
		case syscall.SIGINT:
			log.Printf("%s: Received signal: %s. To shutdown, use 'terminate (SIGTERM)' instead.\n", host, signal)
		case syscall.SIGTERM:
			log.Printf("%s: Received signal: %s. Initiating clean up.\n", host, signal)
			cleanup()
			exitChannel <- true
			return
		default:
			log.Printf("%s: Received %s. No handler defined.\n", host, signal)
		}
	}
}

func cleanup() {
	c, err := redis.Dial("tcp", dbURL)
	if err != nil {
		panic(err)
	}
	defer c.Close()

	log.Printf("%s: Cleaning up counters for graceful shutdown.\n", host)

	// RENAME the key corresponding to the host key that was shutdown
	// This will allow it to be differentiated from currently running replicas
	c.Do("RENAME", host, "~"+host)
}
